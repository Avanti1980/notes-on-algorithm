{"./":{"url":"./","title":"算法导论","keywords":"","body":"算法讲义 github地址 gitee地址 Copyright © Avanti 2022 all right reserved，powered by Gitbook文件最后修改时间： 2022-03-10 23:10:47 "},"posts/Strassen.html":{"url":"posts/Strassen.html","title":"矩阵乘法加速","keywords":"","body":"　　设矩阵\\Av = (a_{ij})和\\Bv = (b_{ij})是n阶方阵，乘积\\Cv = (c_{ij})亦是n阶方阵，其中 \\begin{align*} c_{ij} = \\sum_{k \\in [n]} a_{ik} b_{kj} \\end{align*} 因此按标准的矩阵乘法，计算\\Cv的时间开销为\\Omega(n^3)，事实上这个时间复杂度是可以改进的。 分治递归 　　设计算\\Cv的时间开销为T(n)，将矩阵分成2 \\times 2 = 4块，由分块矩阵乘法有 \\begin{align*} \\begin{bmatrix} \\Cv_{11} & \\Cv_{12} \\\\ \\Cv_{21} & \\Cv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} & \\Av_{12} \\\\ \\Av_{21} & \\Av_{22} \\end{bmatrix} \\begin{bmatrix} \\Bv_{11} & \\Bv_{12} \\\\ \\Bv_{21} & \\Bv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} & \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} & \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} \\end{align*} 其中包含8个n/2阶方阵相乘、4个n/2阶方阵相加，注意每个n/2阶方阵有n^2/4个元素，因此共需进行n^2次加法，综上有递推关系 \\begin{align*} T(n) = 8 \\cdot T(n/2) + c_1 n^2 \\end{align*} 其中c_1为单次加法的时间开销。设n = 2^k，则 \\begin{align*} T(2^k) & = 8^1 \\cdot T(2^{k-1}) + 8^0 \\cdot c_1 4^k \\\\ 8^1 \\cdot T(2^{k-1}) & = 8^2 \\cdot T(2^{k-2}) + 8^1 \\cdot c_1 4^{k-1} \\\\ 8^2 \\cdot T(2^{k-2}) & = 8^3 \\cdot T(2^{k-3}) + 8^2 \\cdot c_1 4^{k-2} \\\\ & \\vdots \\\\ 8^{k-1} \\cdot T(2^1) & = 8^k \\cdot T(2^0) + 8^{k-1} \\cdot c_1 4^1 \\end{align*} 注意8^k = n^3，T(1) = c_2是单次乘法的时间开销，累加可得 \\begin{align*} T(n) & = c_2 n^3 + c_1 4^k + 2^1 \\cdot c_1 4^k + 2^2 \\cdot c_1 4^k + \\cdots + 2^{k-1} \\cdot c_1 4^k = c_2 n^3 + c_1 4^k \\frac{1-2^k}{1-2} \\\\ & = c_2 n^3 + c_1 n^2 (n-1) = (c_2 + c_1) n^3 - c_1 n^2 \\end{align*} 即直接分治递归并不能改进时间复杂度。 基本想法 　　要想改进时间复杂度，必须得减少子问题的个数，即乘法的次数。将乘积拉直，易知 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{12} & \\zerov \\\\ \\zerov & \\Av_{11} & \\zerov & \\Av_{12} \\\\ \\Av_{21} & \\zerov & \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{21} & \\zerov & \\Av_{22} \\end{bmatrix} \\begin{bmatrix} \\Bv_{11} \\\\ \\Bv_{12} \\\\ \\Bv_{21} \\\\ \\Bv_{22} \\end{bmatrix} = \\widetilde{\\Av} \\begin{bmatrix} \\Bv_{11} \\\\ \\Bv_{12} \\\\ \\Bv_{21} \\\\ \\Bv_{22} \\end{bmatrix} \\end{align*} 现假设\\widetilde{\\Av}可以分解成m个“块秩1矩阵”的和： \\begin{align} \\label{eq: decomposition} \\widetilde{\\Av} = \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{12} & \\zerov \\\\ \\zerov & \\Av_{11} & \\zerov & \\Av_{12} \\\\ \\Av_{21} & \\zerov & \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{21} & \\zerov & \\Av_{22} \\end{bmatrix} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Rv_i \\begin{bmatrix} \\Qv_{i1} \\\\ \\Qv_{i2} \\\\ \\Qv_{i3} \\\\ \\Qv_{i4} \\end{bmatrix}^\\top \\end{align} 其中\\Rv_i只由\\Av_{11}, \\Av_{12}, \\Av_{21}, \\Av_{22}进行加减运算得到且\\Pv_{i1}, \\ldots,\\Pv_{i4}, \\Qv_{i1}, \\ldots, \\Qv_{i4} \\in \\{ \\pm \\Iv, \\zerov \\}。则 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Rv_i \\class{green}{\\begin{bmatrix} \\Qv_{i1} \\\\ \\Qv_{i2} \\\\ \\Qv_{i3} \\\\ \\Qv_{i4} \\end{bmatrix}^\\top \\begin{bmatrix} \\Bv_{11} \\\\ \\Bv_{12} \\\\ \\Bv_{21} \\\\ \\Bv_{22} \\end{bmatrix}} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Rv_i \\class{green}{\\Sv_i} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Tv_i \\end{align*} 其中\\Sv_i = \\Qv_{i1} \\Bv_{11} + \\Qv_{i2} \\Bv_{12} + \\Qv_{i3} \\Bv_{21} + \\Qv_{i4} \\Bv_{22}只由\\Bv_{11}, \\Bv_{12}, \\Bv_{21}, \\Bv_{22}进行加减运算得到。计算全部m个\\Tv_i = \\Rv_i \\Sv_i会产生m个子问题。又\\Pv_{i1}, \\ldots, \\Pv_{i4} \\in \\{ \\pm \\Iv, \\zerov \\}，因此 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} = \\sum_{i \\in [m]} \\begin{bmatrix} \\Pv_{i1} \\\\ \\Pv_{i2} \\\\ \\Pv_{i3} \\\\ \\Pv_{i4} \\end{bmatrix} \\Tv_i = \\begin{bmatrix} \\Pv_{11} \\Tv_1 + \\cdots + \\Pv_{m1} \\Tv_m \\\\ \\Pv_{12} \\Tv_1 + \\cdots + \\Pv_{m2} \\Tv_m \\\\ \\Pv_{13} \\Tv_1 + \\cdots + \\Pv_{m3} \\Tv_m \\\\ \\Pv_{14} \\Tv_1 + \\cdots + \\Pv_{m4} \\Tv_m \\end{bmatrix} \\end{align*} 只由\\Tv_1, \\ldots, \\Tv_m进行加减运算得到。综上，关键就是如何使式(\\ref{eq: decomposition})中的m 。 　　下面给出一个m = 7的分解方法，首先去掉左上的\\Av_{11}和右下的\\Av_{22} \\begin{align*} \\widetilde{\\Av} - & \\begin{bmatrix} \\Av_{11} & \\zerov & \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{11} & \\zerov & \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} - \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{22} & \\zerov & \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{22} & \\zerov & \\Av_{22} \\end{bmatrix} = \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\Av_{11} - \\Av_{22} & \\zerov & \\Av_{12} - \\Av_{22} \\\\ \\Av_{21} - \\Av_{11} & \\zerov & \\Av_{22} - \\Av_{11} & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{11} - \\Av_{22} & \\Av_{11} - \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{22} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{12} - \\Av_{22} \\\\ \\Av_{21} - \\Av_{11} & \\Av_{11} - \\Av_{22} & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{11} - \\Av_{22} & \\Av_{11} - \\Av_{22} & \\zerov \\\\ \\zerov & \\Av_{22} - \\Av_{11} & \\Av_{22} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\Av_{22} - \\Av_{12} & \\Av_{12} - \\Av_{22} \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\Av_{12} - \\Av_{11} & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} \\\\ & \\qquad + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\Av_{21} - \\Av_{11} & \\Av_{11} - \\Av_{21} & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\end{bmatrix} + \\begin{bmatrix} \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\zerov & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\\\ \\zerov & \\Av_{21} - \\Av_{22} & \\zerov & \\zerov \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\Iv \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix} \\Av_{11} \\begin{bmatrix} \\Iv \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\Iv \\end{bmatrix} \\Av_{22} \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\Iv \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ -\\Iv \\\\ \\zerov \\end{bmatrix} (\\Av_{11} - \\Av_{22}) \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\Iv \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix} (\\Av_{22} - \\Av_{12}) \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ -\\Iv \\end{bmatrix}^\\top \\\\ & \\qquad + \\begin{bmatrix} \\Iv \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix} (\\Av_{12} - \\Av_{11}) \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix} (\\Av_{21} - \\Av_{11}) \\begin{bmatrix} \\Iv \\\\ -\\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix}^\\top + \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\Iv \\end{bmatrix} (\\Av_{21} - \\Av_{22}) \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix}^\\top \\end{align*} 算法实现 　　根据上面的分解易知计算 \\begin{align*} \\begin{bmatrix} \\Sv_1 \\\\ \\Sv_2 \\\\ \\Sv_3 \\\\ \\Sv_4 \\\\ \\Sv_5 \\\\ \\Sv_6 \\\\ \\Sv_7 \\end{bmatrix} = \\begin{bmatrix} \\Iv & \\zerov & \\Iv & \\zerov \\\\ \\zerov & \\Iv & \\zerov & \\Iv \\\\ \\zerov & \\Iv & \\Iv & \\zerov \\\\ \\zerov & \\zerov & \\Iv & -\\Iv \\\\ \\zerov & \\zerov & \\Iv & \\zerov \\\\ \\Iv & -\\Iv & \\zerov & \\zerov \\\\ \\zerov & \\Iv & \\zerov & \\zerov \\end{bmatrix} \\begin{bmatrix} \\Bv_{11} \\\\ \\Bv_{12} \\\\ \\Bv_{21} \\\\ \\Bv_{22} \\end{bmatrix} = \\begin{bmatrix} \\Bv_{11} + \\Bv_{21} \\\\ \\Bv_{12} + \\Bv_{22} \\\\ \\Bv_{12} + \\Bv_{21} \\\\ \\Bv_{21} - \\Bv_{22} \\\\ \\Bv_{21} \\\\ \\Bv_{11} - \\Bv_{12} \\\\ \\Bv_{12} \\end{bmatrix}, \\quad \\begin{bmatrix} \\Rv_1 \\\\ \\Rv_2 \\\\ \\Rv_3 \\\\ \\Rv_4 \\\\ \\Rv_5 \\\\ \\Rv_6 \\\\ \\Rv_7 \\end{bmatrix} = \\begin{bmatrix} \\Av_{11} \\\\ \\Av_{22} \\\\ \\Av_{11} - \\Av_{22} \\\\ \\Av_{22} - \\Av_{12} \\\\ \\Av_{12} - \\Av_{11} \\\\ \\Av_{21} - \\Av_{11} \\\\ \\Av_{21} - \\Av_{22} \\end{bmatrix} \\end{align*} 共会产生10次加减运算，计算\\Tv_1 = \\Rv_1 \\Sv_1, \\ldots, \\Tv_7 = \\Rv_7 \\Sv_7共会产生7个子问题，最后计算 \\begin{align*} \\begin{bmatrix} \\Av_{11} \\Bv_{11} + \\Av_{12} \\Bv_{21} \\\\ \\Av_{11} \\Bv_{12} + \\Av_{12} \\Bv_{22} \\\\ \\Av_{21} \\Bv_{11} + \\Av_{22} \\Bv_{21} \\\\ \\Av_{21} \\Bv_{12} + \\Av_{22} \\Bv_{22} \\end{bmatrix} & = \\begin{bmatrix} \\Iv \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix} \\Tv_1 + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\Iv \\end{bmatrix} \\Tv_2 + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ -\\Iv \\\\ \\zerov \\end{bmatrix} \\Tv_3 + \\begin{bmatrix} \\zerov \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix} \\Tv_4 + \\begin{bmatrix} \\Iv \\\\ \\Iv \\\\ \\zerov \\\\ \\zerov \\end{bmatrix} \\Tv_5 + \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\zerov \\end{bmatrix} \\Tv_6 + \\begin{bmatrix} \\zerov \\\\ \\zerov \\\\ \\Iv \\\\ \\Iv \\end{bmatrix} \\Tv_7 \\\\ & = \\begin{bmatrix} \\Tv_1 + \\Tv_5 \\\\ \\Tv_2 + \\Tv_3 + \\Tv_4 + \\Tv_5 \\\\ \\Tv_1 - \\Tv_3 + \\Tv_6 + \\Tv_7 \\\\ \\Tv_2 + \\Tv_7 \\end{bmatrix} \\end{align*} 共会产生8次加减运算。 　　综上，一共会产生7个子问题和18次加减运算，此时递推关系变成 \\begin{align*} T(n) = 7 \\cdot T(n/2) + \\frac{18}{4} c_1 n^2 \\end{align*} 设n = 2^k，则 \\begin{align*} T(2^k) & = 7^1 \\cdot T(2^{k-1}) + \\frac{18}{4} c_1 4^k \\\\ 7^1 \\cdot T(2^{k-1}) & = 7^2 \\cdot T(2^{k-2}) + 7^1 \\frac{18}{4} c_1 4^{k-1} \\\\ 7^2 \\cdot T(2^{k-2}) & = 7^3 \\cdot T(2^{k-3}) + 7^2 \\frac{18}{4} c_1 4^{k-2} \\\\ & \\vdots \\\\ 7^{k-1} \\cdot T(2^1) & = 7^k \\cdot T(2^0) + 7^{k-1} \\frac{18}{4} c_1 4^1 \\end{align*} 注意7^k = (2^{\\lg 7})^k = (2^k)^{\\lg 7} = n^{\\lg 7} \\approx n^{2.81}， 累加可得 \\begin{align*} T(n) = c_2 n^{\\lg 7} + \\frac{18}{4} c_1 4^k \\frac{1-(7/4)^k}{1-(7/4)} = c_2 n^{\\lg 7} + 6 c_1 (n^{\\lg 7} - n^2) = \\left( c_2 + 6 c_1 \\right) n^{\\lg 7} - 6 c_1 n^2 \\end{align*} Copyright © Avanti 2022 all right reserved，powered by Gitbook文件最后修改时间： 2022-03-10 23:10:47 "},"posts/master-theorem.html":{"url":"posts/master-theorem.html","title":"主定理证明","keywords":"","body":"主定理：令a \\ge 1和b > 1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： \\begin{align*} T(n) = a \\cdot \\left( \\frac{n}{b} \\right) + f(n) \\end{align*} 其中我们将n/b解释为\\lfloor n/b \\rfloor或\\lceil n/b \\rceil，那么T(n)有如下渐进界： 若对某个常数\\varepsilon > 0有f(n) = O(n^{\\log_b a - \\varepsilon})，则T(n) = \\Theta (n^{\\log_b a})。 若f(n) = \\Theta (n^{\\log_b a})，则T(n) = \\Theta (n^{\\log_b a} \\lg n)。 若对某个常数\\varepsilon > 0有f(n) = \\Omega(n^{\\log_b a + \\varepsilon})，且对某个常数c和所有足够大的n有a f(n/b) \\le c f(n)，则T(n) = \\Theta (f(n))。 证明：若n是b的整数幂次，不妨设n = b^k，此时n/b最后正好会递归成1，即 \\begin{align*} T \\left( \\frac{n}{b^0} \\right) & = a \\cdot T \\left( \\frac{n}{b^1} \\right) + f \\left( \\frac{n}{b^0} \\right) \\\\ T \\left( \\frac{n}{b^1} \\right) & = a \\cdot T \\left( \\frac{n}{b^2} \\right) + f \\left( \\frac{n}{b^1} \\right) \\\\ & \\vdots \\\\ T \\left( \\frac{n}{b^{k-1}} \\right) & = a \\cdot T \\left( \\frac{n}{b^k} \\right) + f \\left( \\frac{n}{b^{k-1}} \\right) \\end{align*} 注意上面共有k个递推式，又a^k = (b^{\\log_b a})^k = (b^k)^{\\log_b a} = n^{\\log_b a}、n = b^k，于是 \\begin{align*} T(n) = a^k \\cdot T \\left( \\frac{n}{b^k} \\right) + f \\left( \\frac{n}{b^0} \\right) + a f \\left( \\frac{n}{b^1} \\right) + \\cdots + a^{k-1} f \\left( \\frac{n}{b^{k-1}} \\right) = n^{\\log_b a} \\cdot T(1) + \\sum_{i=0}^{k-1} a^i f \\left( \\frac{n}{b^i} \\right) \\end{align*} 显然前一项n^{\\log_b a} \\cdot T(1) = \\Theta(n^{\\log_b a})，故关键就是后面求和这一项，下面分情况讨论： 由f(n) = O(n^{\\log_b a - \\varepsilon})可知 \\begin{align*} a^i f \\left( \\frac{n}{b^i} \\right) = a^i O \\left( \\left( \\frac{n}{b^i} \\right)^{\\log_b a - \\varepsilon} \\right) = a^i O \\left( \\frac{n^{\\log_b a - \\varepsilon}}{a^i b^{-\\varepsilon i}} \\right) = O(n^{\\log_b a - \\varepsilon}) b^{\\varepsilon i} \\end{align*} 故 \\begin{align*} g(n) = \\sum_{i=0}^{k-1} f \\left( \\frac{n}{b^i} \\right) = O(n^{\\log_b a - \\varepsilon}) \\sum_{i=0}^{k-1} b^{\\varepsilon i} = O(n^{\\log_b a - \\varepsilon}) \\frac{1 - b^{k \\varepsilon}}{1 - b^\\varepsilon} = O(n^{\\log_b a - \\varepsilon}) \\frac{n^\\varepsilon - 1}{b^\\varepsilon - 1} = O(n^{\\log_b a}) \\end{align*} 从而T(n) = \\Theta(n^{\\log_b a}) + O(n^{\\log_b a}) = \\Theta(n^{\\log_b a})，即此时T(n)的复杂度由前一项决定。 由f(n) = \\Theta (n^{\\log_b a})可知 \\begin{align*} a^i f \\left( \\frac{n}{b^i} \\right) = a^i \\Theta \\left( \\left( \\frac{n}{b^i} \\right)^{\\log_b a} \\right) = a^i \\Theta \\left( \\frac{n^{\\log_b a}}{a^i} \\right) = \\Theta(n^{\\log_b a}) \\end{align*} 于是 \\begin{align*} g(n) = \\sum_{i=0}^{k-1} a^i f \\left( \\frac{n}{b^i} \\right) = \\sum_{i=0}^{k-1} \\Theta(n^{\\log_b a}) = \\Theta(n^{\\log_b a}) \\log_b n = \\Theta(n^{\\log_b a} \\lg n) \\end{align*} 从而T(n) = \\Theta(n^{\\log_b a}) + \\Theta(n^{\\log_b a} \\lg n) = \\Theta(n^{\\log_b a} \\lg n)，即此时T(n)的复杂度由求和这一项决定。 由条件知存在j使得当n' \\ge b^{k-j+1} = n / b^{j-1}时递推式a f(n'/b) \\le c f(n')恒成立，于是 \\begin{align*} a^j f \\left( \\frac{n}{b^j} \\right) \\le a^{j-1} c f \\left( \\frac{n}{b^{j-1}} \\right) \\le \\cdots \\le a^2 c^{j-2} f \\left( \\frac{n}{b^2} \\right) \\le a c^{j-1} f \\left( \\frac{n}{b} \\right) \\le c^j f(n) \\end{align*} 从而对\\forall i \\le j有a^i f(n/b^i) \\le c^{i} f(n)，代入可得 \\begin{align*} g(n) & = \\sum_{i=0}^{k-1} a^i f \\left( \\frac{n}{b^i} \\right) = \\sum_{i=0}^j a^i f \\left( \\frac{n}{b^i} \\right) + \\overbrace{a^{j+1} f \\left(\\frac{n}{b^{j+1}} \\right) + \\cdots + a^{k-1} f \\left(\\frac{n}{b^{k-1}} \\right)}^{\\text{不满足递推式的部分，复杂度为}O(1)} \\\\ & \\le \\sum_{i=0}^j c^i f(n) + O(1) f(n)是g(n)中的一项且g(n)所有求和项非负，故g(n) \\ge f(n)，从而 \\begin{align*} g(n) = \\Theta (f(n)) = \\Omega(n^{\\log_b a + \\varepsilon}) > \\Theta(n^{\\log_b a}) \\end{align*} 于是T(n) = \\Theta(n^{\\log_b a}) + g(n) = \\Theta (f(n))，即此时T(n)的复杂度由求和这一项决定。 　　若n不是b的整数幂次，则递推中某一轮n/b不一定为整数，又T(n)是定义在非负整数上的，因此还需多做一步取整，此时递推式可写成 \\begin{align*} T(n_0) & = a \\cdot T(n_1) + f(n_0), \\quad n_1 = [n_0/b] \\\\ T(n_1) & = a \\cdot T(n_2) + f(n_1), \\quad n_2 = [n_1/b] \\\\ T(n_2) & = a \\cdot T(n_3) + f(n_2), \\quad n_3 = [n_2/b] \\\\ & \\vdots \\end{align*} 不妨先考虑向上取整，即 \\begin{align*} n_i = \\begin{cases} n & i = 0 \\\\ \\lceil n_{i-1} / b \\rceil & i > 0 \\end{cases} \\end{align*} 根据x \\le \\lceil x \\rceil \\le x + 1易知 \\begin{align*} \\frac{n}{b} \\le n_1 & \\le \\frac{n}{b} + 1 \\\\ \\frac{n}{b^2} \\le n_2 & \\le \\frac{n}{b^2} + \\frac{1}{b} + 1 \\\\ \\frac{n}{b^3} \\le n_3 & \\le \\frac{n}{b^3} + \\frac{1}{b^2} + \\frac{1}{b} + 1 \\\\ \\vdots & \\end{align*} 于是 \\begin{align} \\label{eq: ni-upper-bound} \\frac{n}{b^i} \\le n_i \\le \\frac{n}{b^i} + \\frac{1}{b^{i-1}} + \\cdots + \\frac{1}{b} + 1 k = \\lfloor \\log_b n \\rfloor \\ge \\log_b n - 1，即n \\le b^{k+1}，代入式(\\ref{eq: ni-upper-bound})可得 \\begin{align*} n_k k轮，子问题T(n_k)已经是O(1)复杂度了，同前面一样有 \\begin{align*} T(n) = a^k T(n_k) + f(n_0) + a f(n_1) + \\cdots + a^{k-1} f(n_{k-1}) = \\Theta(n^{\\log_b a}) + \\sum_{i=0}^{k-1} a^i f(n_i) \\end{align*} 关键依然是后面求和这一项，继续分情况讨论： 由f(n) = O(n^{\\log_b a - \\varepsilon})可知存在正常数c_i和n_i使得对\\forall n \\ge n_i有 \\begin{align*} a^i f(n_i) & \\le a^i c_i n_i^{\\log_b a - \\varepsilon} \\cbar = \\max_i \\{c_i\\}、\\nbar = \\max_i \\{n_i\\}，于是对\\forall n \\ge \\nbar有 \\begin{align*} g(n) & = \\sum_{i=0}^{k-1} a^i f(n_i) T(n) = \\Theta(n^{\\log_b a}) + O(n^{\\log_b a}) = \\Theta(n^{\\log_b a})，即此时T(n)的复杂度由前一项决定。 由f(n) = \\Theta (n^{\\log_b a})可知存在正常数c_i、d_i和n_i使得对\\forall n \\ge n_i有 \\begin{align*} a^i f(n_i) \\le a^i c_i n_i^{\\log_b a} a^i f(n_i) = \\Theta(n^{\\log_b a})，于是 \\begin{align*} g(n) = \\sum_{i=0}^{k-1} a^i f(n_i) = \\Theta(n^{\\log_b a}) k = \\Theta(n^{\\log_b a} \\lg n) \\end{align*} 从而T(n) = \\Theta(n^{\\log_b a}) + \\Theta(n^{\\log_b a} \\lg n) = \\Theta(n^{\\log_b a} \\lg n)，即此时T(n)的复杂度由求和这一项决定。 由条件知存在j使得当n \\ge n_{j-1}时递推式a f(\\lceil n/b \\rceil) \\le c f(n)恒成立，于是 \\begin{align*} a^j f(n_j) \\le a^{j-1} c f(n_{j-1}) \\le \\cdots \\le a^2 c^{j-2} f(n_2) \\le a c^{j-1} f(n_1) \\le c^j f(n_0) \\end{align*} 从而对\\forall i \\le j有a^i f(n_i) \\le c^{i} f(n)，代入可得 \\begin{align*} g(n) & = \\sum_{i=0}^{k-1} a^i f(n_i) = \\sum_{i=0}^j a^i f(n_i) + \\overbrace{a^{j+1} f(n_{j+1}) + \\cdots + a^{k-1} f(n_{k-1})}^{\\text{不满足递推式的部分，复杂度为}O(1)} \\\\ & \\le \\sum_{i=0}^j c^i f(n) + O(1) f(n)是g(n)中的一项且g(n)所有求和项非负，故g(n) \\ge f(n)，从而 \\begin{align*} g(n) = \\Theta (f(n)) = \\Omega(n^{\\log_b a + \\varepsilon}) > \\Theta(n^{\\log_b a}) \\end{align*} 于是T(n) = \\Theta(n^{\\log_b a}) + g(n) = \\Theta (f(n))，即此时T(n)的复杂度由求和这一项决定。 　　最后考虑向下取整，即 \\begin{align*} n_i = \\begin{cases} n & i = 0 \\\\ \\lfloor n_{i-1}/b \\rfloor & i > 0 \\end{cases} \\end{align*} 根据x-1 \\le \\lfloor x \\rfloor \\le x易知 \\begin{align*} \\frac{n}{b} - 1 \\le n_1 & \\le \\frac{n}{b} \\\\ \\frac{n}{b^2} - \\frac{1}{b} - 1 \\le n_2 & \\le \\frac{n}{b^2} \\\\ \\frac{n}{b^3} - \\frac{1}{b^2} - \\frac{1}{b} - 1 \\le n_3 & \\le \\frac{n}{b^3} \\\\ \\vdots & \\end{align*} 于是 \\begin{align} \\label{eq: ni-lower-bound} \\frac{n}{b^i} - \\frac{b}{b-1} = \\frac{n}{b^i} - \\frac{1}{1 - 1/b} k = \\lfloor \\log_b n(b-1) \\rfloor - 2 \\ge \\log_b n(b-1) - 3，即n(b-1) \\le b^{k+3}，代入式(\\ref{eq: ni-lower-bound})可得 \\begin{align*} n_k \\le \\frac{n}{b^k} \\le \\frac{b^{k+3}}{b^k} = \\frac{b^3}{b-1} = O(1) \\end{align*} 故递推到第k轮，子问题T(n_k)已经是O(1)复杂度了，同前面一样有 \\begin{align*} T(n) = a^k T(n_k) + f(n_0) + a f(n_1) + \\cdots + a^{k-1} f(n_{k-1}) = \\Theta(n^{\\log_b a}) + \\sum_{i=0}^{k-1} a^i f(n_i) \\end{align*} 关键依然是后面求和这一项，继续分情况讨论： 由f(n) = O(n^{\\log_b a - \\varepsilon})可知存在正常数c_i和n_i使得对\\forall n \\ge n_i有 \\begin{align*} a^i f(n_i) \\le a^i c_i n_i^{\\log_b a - \\varepsilon} \\cbar = \\max_i \\{c_i\\}、\\nbar = \\max_i \\{n_i\\}，于是对\\forall n \\ge \\nbar有 \\begin{align*} g(n) = \\sum_{i=0}^{k-1} a^i f(n_i) T(n) = \\Theta(n^{\\log_b a}) + O(n^{\\log_b a}) = \\Theta(n^{\\log_b a})，即此时T(n)的复杂度由前一项决定。 由f(n) = \\Theta (n^{\\log_b a})可知存在正常数c_i、d_i和n_i使得对\\forall n \\ge n_i有 \\begin{align*} a^i f(n_i) \\le a^i c_i n_i^{\\log_b a} \\le a^i c_i \\left( \\frac{n}{b^i} \\right)^{\\log_b a} \\le c_i n^{\\log_b a} = O(n^{\\log_b a}) \\end{align*} 以及 \\begin{align*} a^i f(n_i) & \\ge a^i d_i n_i^{\\log_b a} \\ge a^i d_i \\left( \\frac{n}{b^i} - \\frac{b}{b-1} \\right)^{\\log_b a} = a^i d_i \\left( \\frac{n}{b^i} \\right)^{\\log_b a} \\left( 1 - \\frac{b^i}{n} \\frac{b}{b-1} \\right)^{\\log_b a} \\\\ & = d_i n^{\\log_b a} \\left( 1 - \\frac{b^i}{n} \\frac{b}{b-1} \\right)^{\\log_b a} \\end{align*} 注意k = \\lfloor \\log_b n(b-1) \\rfloor - 2 \\le \\log_b n(b-1) - 2，即n(b-1) \\ge b^{k+2}，于是 \\begin{align*} 1 > 1 - \\frac{b^i}{n} \\frac{b}{b-1} \\ge 1 - \\frac{b^{i+1}}{b^{k+2}} > 0 \\Longrightarrow 1 - \\frac{b^i}{n} \\frac{b}{b-1} \\in (0,1) \\Longrightarrow a^i f(n_i) = \\Omega (n^{\\log_b a}) \\end{align*} 故a^i f(n_i) = \\Theta(n^{\\log_b a})，于是 \\begin{align*} g(n) = \\sum_{i=0}^{k-1} a^i f(n_i) = \\Theta(n^{\\log_b a}) k = \\Theta(n^{\\log_b a} \\lg n) \\end{align*} 从而T(n) = \\Theta(n^{\\log_b a}) + \\Theta(n^{\\log_b a} \\lg n) = \\Theta(n^{\\log_b a} \\lg n)，即此时T(n)的复杂度由求和这一项决定。 由条件知存在j使得当n \\ge n_{j-1}时递推式a f(\\lfloor n/b \\rfloor) \\le c f(n)恒成立，于是 \\begin{align*} a^j f(n_j) \\le a^{j-1} c f(n_{j-1}) \\le \\cdots \\le a^2 c^{j-2} f(n_2) \\le a c^{j-1} f(n_1) \\le c^j f(n_0) \\end{align*} 从而对\\forall i \\le j有a^i f(n_i) \\le c^{i} f(n)，代入可得 \\begin{align*} g(n) & = \\sum_{i=0}^{k-1} a^i f(n_i) = \\sum_{i=0}^j a^i f(n_i) + \\overbrace{a^{j+1} f(n_{j+1}) + \\cdots + a^{k-1} f(n_{k-1})}^{\\text{不满足递推式的部分，复杂度为}O(1)} \\\\ & \\le \\sum_{i=0}^j c^i f(n) + O(1) f(n)是g(n)中的一项且g(n)所有求和项非负，故g(n) \\ge f(n)，从而 \\begin{align*} g(n) = \\Theta (f(n)) = \\Omega (n^{\\log_b a + \\varepsilon}) > \\Theta(n^{\\log_b a}) \\end{align*} 于是T(n) = \\Theta(n^{\\log_b a}) + g(n) = \\Theta (f(n))，即此时T(n)的复杂度由求和这一项决定。 Copyright © Avanti 2022 all right reserved，powered by Gitbook文件最后修改时间： 2022-03-11 01:23:50 "}}